#!/usr/bin/ruby -w


require 'lib/debug'
require 'lib/checkrights'
require 'lib/nodes'
require 'lib/config'
require 'lib/stepdeployenv'
require 'lib/stepbroadcastenv'
require 'lib/stepbootnewenv'
require 'thread'
require 'optparse'


class MagicCookie
end

class WindowManager

end

class QueueManager
  @queue_deployment_environment = nil
  @queue_broadcast_environment = nil
  @queue_boot_new_environment = nil
  @queue_process_finished_nodes = nil
  attr_reader :config
  @nodes_ok = nil
  @nodes_ko = nil
  @mutex = nil
  attr_accessor :nb_active_threads

  def initialize(config, nodes_ok, nodes_ko)
    @config = config
    @nodes_ok = nodes_ok
    @nodes_ko = nodes_ko
    @mutex = Mutex.new
    @nb_active_threads = 0
    @queue_deployment_environment = Queue.new
    @queue_broadcast_environment = Queue.new
    @queue_boot_new_environment = Queue.new
    @queue_process_finished_nodes = Queue.new
  end

  def increment_active_threads
    @mutex.synchronize {
      @nb_active_threads += 1
    }
  end

  def decrement_active_threads
    @mutex.synchronize {
      @nb_active_threads -= 1
    }
  end

  def one_last_active_thread?
    @mutex.synchronize {
      return (@nb_active_threads == 1)
    }
  end

  def no_more_active_thread?
    @mutex.synchronize {
      return (@nb_active_threads == 0)
    }
  end

  def next_macro_step(current_step, nodes)
    if (nodes.set.empty?)
      raise "Empty node set"
    else
      case current_step
      when nil
        @queue_deployment_environment.push(nodes)
      when /SetDeploymentEnv/
        @queue_broadcast_environment.push(nodes)
      when /BroadcastEnv/
        @queue_boot_new_environment.push(nodes)
      when /BootNewEnv/
        @queue_process_finished_nodes.push(nodes)
      else
        raise "Wrong step name"
      end
    end
  end
  
  def add_to_bad_nodes_set(nodes)
    @nodes_ko.add(nodes)
    if one_last_active_thread? then
      #We add an empty node_set to the last state queue
      @queue_process_finished_nodes.push(Nodes::NodeSet.new)
    end
  end

  def get_task(queue)
    case queue
    when /SetDeploymentEnv/
      return @queue_deployment_environment.pop
    when /BroadcastEnv/
      return @queue_broadcast_environment.pop
    when /BootNewEnv/
      return @queue_boot_new_environment.pop
    when /ProcessFinishedNodes/
      return @queue_process_finished_nodes.pop
    else
      raise "Wrong queue name"
    end
  end
  
  def send_exit_signal
    @queue_deployment_environment.push(MagicCookie.new)
    @queue_broadcast_environment.push(MagicCookie.new)
    @queue_boot_new_environment.push(MagicCookie.new) 
    @queue_process_finished_nodes.push(MagicCookie.new)
  end
end

class WindowManager
  attr_accessor :reboot
  attr_accessor :ssh
end

class KadeployWorkflow
  @thread_set_deployment_environment = nil
  @thread_broadcast_environment = nil
  @thread_boot_new_environment = nil 
  @thread_process_finished_nodes = nil
  @queue_manager = nil
  @output = nil
  @rights = nil
  @nodeset = nil
  @config = nil
  @window_manager = nil
  attr_accessor :nodes_ok
  attr_accessor :nodes_ko

  def initialize(config, nodeset)
    @config = config
    @output = Debug::OutputControl.new(@config.common.debug_level)
    @rights = CheckRights::CheckRightsFactory.new(@config.common.rights_kind).klass
    @nodes_ok = Nodes::NodeSet.new
    @nodes_ko = Nodes::NodeSet.new
    @nodeset = nodeset
    @queue_manager = QueueManager.new(@config, @nodes_ok, @nodes_ko)
    @window_manager = WindowManager.new

    @thread_set_deployment_environment = Thread.new {
      launch_thread_for_macro_step("SetDeploymentEnv")
    }
    @thread_broadcast_environment = Thread.new {
      launch_thread_for_macro_step("BroadcastEnv")
    }
    @thread_boot_new_environment = Thread.new {
      launch_thread_for_macro_step("BootNewEnv")
    }
    @thread_process_finished_nodes = Thread.new {
      launch_thread_for_macro_step("ProcessFinishedNodes")
    }
  end
  
  def launch_thread_for_macro_step(kind)
    close_thread = false
    @output.debugl(0, "#{kind} thread launched")
    while (not close_thread) do
      nodes = @queue_manager.get_task(kind)
      #We receive the signal to exit
      if (nodes.kind_of?(MagicCookie)) then
        close_thread = true
      else
        if kind != "ProcessFinishedNodes" then
          nodes.group_by_cluster.each_pair { |cluster, set|
            macro_step_instance = @config.cluster_specific[cluster].get_macro_step(kind).get_instance
            case kind
            when "SetDeploymentEnv"
              SetDeploymentEnvironnment::SetDeploymentEnvFactory.new(macro_step_instance[0], 
                                                                     macro_step_instance[1],
                                                                     cluster,
                                                                     set,
                                                                     @queue_manager,
                                                                     @window_manager,
                                                                     @output).klass.run
            when "BroadcastEnv"
              BroadcastEnvironment::BroadcastEnvFactory.new(macro_step_instance[0], 
                                                            macro_step_instance[1], 
                                                            cluster,
                                                            set,
                                                            @queue_manager,
                                                            @window_manager,
                                                            @output).klass.run
            when "BootNewEnv"
              BootNewEnvironment::BootNewEnvFactory.new(macro_step_instance[0], 
                                                        macro_step_instance[1], 
                                                        cluster,
                                                        set,
                                                        @queue_manager,
                                                        @window_manager,
                                                        @output).klass.run
            else
              raise "Invalid macro step name"
            end
          }
        else
          #in this case, all is ok
          if not nodes.empty? then
            @nodes_ok.add(nodes)
          end
          if ((nodes.empty? && @queue_manager.one_last_active_thread?) || \
              (not nodes.empty? && @queue_manager.no_more_active_thread?)) then
            @nodes_ok.group_by_cluster.each_pair { |cluster, set|
              puts "Nodes correctly deployed on cluster #{cluster}"
              puts set.to_s
            }
            @nodes_ko.group_by_cluster.each_pair { |cluster, set|
              puts "Nodes not Correctly deployed on cluster #{cluster}"
              puts set.to_s
            }
            @queue_manager.send_exit_signal
            @thread_set_deployment_environment.join
            @thread_broadcast_environment.join
            @thread_boot_new_environment.join
          else
            puts @queue_manager.nb_active_threads
          end
        end
      end
    end
  end

  def run
    puts "Launching Kadeploy ..."
    if (@rights.granted? == true)
      @queue_manager.next_macro_step(nil, @nodeset)
      @thread_process_finished_nodes.join
    else
      puts "You do not have the deployment rights on all the nodes"
    end
  end
end

n1=Nodes::Node.new("virtual_host_1", "192.168.0.10", "paravent")
n2=Nodes::Node.new("virtual_host_2", "192.168.0.11", "paravent")
n3=Nodes::Node.new("virtual_host_3", "192.168.0.12", "paravent")
n4=Nodes::Node.new("virtual_host_4", "192.168.0.13", "paravent")
ns=Nodes::NodeSet.new
ns.push(n1)
ns.push(n2)
ns.push(n3)
ns.push(n4)

Signal.trap("INT") do
  puts "SIGINT trapped, let's clean everything ..."
  #todo: clean some stuff
  exit 1
end

config = ConfigInformation::Config.new
if (config.load_cmdline_options == true)
  workflow=KadeployWorkflow.new(config, ns)
  workflow.run
end
