#!/usr/bin/perl

# needs a configuration file that should be found at /etc/kadeploy/deploy_cmd.conf

use File::Copy;
use Getopt::Long;
use libkadeploy2::conflib;
use libkadeploy2::bootlib;
use libkadeploy2::deploy_iolib;
use libkadeploy2::node_bd;

use strict;

my $soft = 0;
my $hard = 0;
my $deploy = 0;
my $noreboot = 0;
my @host_list = ();
my $env = "";
my $device="";
my $reboot = "";
my $query = "";
my @hosts_to_reboot = (); # list of nodes to reboot
my $verbose = 0;
my $debug = 1;
my $node_file;
my $username = getpwuid($ENV{SUDO_UID}); # real user

if (!@ARGV){
    print "Usage : kareboot [-s|--soft] [-h|--hard] [-d|--deploy] [-n|--noreboot] -m|--machine hostname [-e|--environment name] [-p|--partition partition]\n";
    exit 0;
}

## gets the options
GetOptions('m=s'           => \@host_list,
	   'machine=s'     => \@host_list,
	   'f=s'           => \$node_file,	   
	   'e=s'           => \$env,
	   'environment=s' => \$env,
	   's'             => \$soft,
	   'soft'          => \$soft,
	   'h'             => \$hard,
	   'hard'          => \$hard,
	   'd'             => \$deploy,
	   'deploy'        => \$deploy,
	   'n'             => \$noreboot,
	   'noreboot'      => \$noreboot,
	   'p=s'           => \$device,
	   'partition=s'   => \$device,
	   'verbose'       => \$verbose,
	   'v'             => \$verbose
	   );


if ($node_file)
{
    my $line;
    open(NODEFILE,$node_file) or die "Can't open node_file : $node_file\n";
    while ($line = <NODEFILE>)
    {
	if ($line =~ /([a-zA-Z0-9\.]+)/) { $line = $1; }
	chomp($line);
	push(@host_list, $line);
    }
    close(NODEFILE);
}


## checks if needed options are defined
if (!scalar(@host_list)){
    print "Usage : kareboot [-s|--soft] [-h|--hard] [-d|--deploy] [-n|--noreboot] -m|--machine hostname [-e|--environment name] [-p|--partition partition]\n";
    exit 0;
}
if ($soft && $hard){
    print "ERROR : soft and hard reboot options are exclusive\n";
    print "ERROR : please select only one of them at once\n";
    exit 0;
}

if (($noreboot && $soft) || ($noreboot && $hard)){
    print "ERROR : no reboot and soft or hard reboot should be exclusive\n";
    print "ERROR : please select only one of them at once\n";
    exit 0;
}

if (($deploy && $env) || ($deploy && $device) || ($env && $device)){
    print "ERROR : please select EITHER a deployment reboot OR a reboot on a partition OR a reboot on an environment\n";
    exit 0;
}


# checks if tftp folders exist
my $intel_tftp = libkadeploy2::conflib::get_conf("tftp_repository_intel") . libkadeploy2::conflib::get_conf("tftp_relative_path");
my $tftp = libkadeploy2::conflib::get_conf("tftp_repository") . libkadeploy2::conflib::get_conf("tftp_relative_path");
if((!(-e $intel_tftp)) || (!(-e $tftp))){
    print "ERROR : unknown tftp folder\n";
    print "ERROR : please check your configuration file\n";
    exit 0;
}


# defines reboot type
if ($hard) {
    $reboot = "hardboot";
} elsif ($noreboot) {
    $reboot = "noreboot";
} else { # default is soft
    $reboot = "softboot";
}

# defines query type
if ($deploy) {
    $query = "deployboot";
} elsif ($env) {
    $query = "envboot";
} elsif ($device) {
    $query = "devboot";
}

## Available variables are :
## - @host_list - list of hosts to reboot
## - $env - environment name
##  OR
## - $device - device and partition number

my %cmd = libkadeploy2::conflib::check_cmd;


foreach my $host (@host_list){
    my $dev = "";
    my $part = "";
    my %node_info;
    my @env_info = ();
    my $deployment;

    # debug print 
    # print "NOREBOOT = $noreboot ; SOFT = $soft ; HARD = $hard ; DEPLOY = $deploy\n";

    if( (!$cmd{$host}{$reboot}) && (!$noreboot)){
	print "WARNING : no $reboot command found for $host !\n";
    } else {
	# debug print
	# print "to be executed : $host -> $cmd{$host}{$reboot}\n";
	
	my $base = libkadeploy2::deploy_iolib::connect();

	## added for the optimisation methods
	## new deployment creation
	if ($env)
	{
	    $deployment = libkadeploy2::deploy_iolib::prepare_deployment($base);
	    if (!$deployment)
	    {
		libkadeploy2::deploy_iolib::disconnect($base);
		  print "ERROR : can't create a new deployment\n";
		  exit 1;
	      }
	}


	if($deploy) {
	  if(!$cmd{$host}{$query}){
	    print "WARNING : no $query command found for $host !\n";
	  } else{
	    system("$cmd{$host}{$query}");
	    push (@hosts_to_reboot, $host);
	  }
	} elsif ($env) {
	  # searches for partition with requested environment
	  my @res = libkadeploy2::deploy_iolib::search_deployed_env($base,$env,$host);
	  if(scalar(@res)) {
	    # gets device and part number of the first partition by default for the moment
	    $dev  = libkadeploy2::deploy_iolib::disk_id_to_dev($base,$res[0][0]);
	    $part = libkadeploy2::deploy_iolib::part_id_to_nb($base,$res[0][1]);

	    # debug print
	    # print "DEV = $dev ; PART = $part ; That's it !\n";

	    my $deploy_id = libkadeploy2::deploy_iolib::get_deploy_id($base,$host,$dev,$part);
	    if(!$deploy_id) {
	      print "WARNING : target node/device/partition does not exist or partition is not currently correctly deployed\n";
	    } else {
	 	       ## added for the optimisation methods
	      $env=$env_info[0];	      
	      #print "$env";
	      # until here
	     @env_info = libkadeploy2::deploy_iolib::deploy_id_to_env_info($base,$deploy_id);
	    }
	  }

	} elsif($device) {
	  # separates device and partition number from $device
	  $dev = substr($device, 0, 3);
	  my @nb = split(/$dev/, $device);
	  $part = $nb[1];

	  # gets the environment installed on
	  my $deploy_id = libkadeploy2::deploy_iolib::get_deploy_id($base,$host,$dev,$part);
	  if (!$deploy_id) {
	    print "WARNING : target node/device/partition does not exist or partition is not currently correctly deployed\n";
	  } else {
	     ## added for the optimisation methods
	    $env=$env_info[0];
            #print "$env";
	    #until here

	    @env_info = libkadeploy2::deploy_iolib::deploy_id_to_env_info($base,$deploy_id);
	  }

	} else { # no environnement or device to boot on specified
	    print ("[VERBOSE] No environement or device specified for $host added to nodes to reboot\n") if $debug;
	    push (@hosts_to_reboot, $host);
	     ## added for the optimisation methods
	    $env=libkadeploy2::deploy_iolib::node_last_dep_env($base,$host);
	    $part=libkadeploy2::deploy_iolib::node_last_dep($base,$host);
	    $dev=libkadeploy2::deploy_iolib::node_last_dep_dev($base,$host);
	    #until here

	}

	if ($dev && $part && scalar(@env_info)) {
	  # grub and pxe
	  my $ip = libkadeploy2::deploy_iolib::node_name_to_ip($base,$host);
	  $node_info{$ip} = [$dev,$part];
	  libkadeploy2::bootlib::manage_grub_pxe(\%node_info,\@env_info);
	  push (@hosts_to_reboot, $host);
	}


	#added for the optimisation methods
	## begins deployment (updates deployed table)	
	if ($env)
	{
	    my $tmp_node;
	    # for the moment, nodes' name and IP are the same
	    foreach my $host (@hosts_to_reboot){
		$tmp_node = libkadeploy2::node_bd->new($host, $deployment, $env, $dev, $part);
	    }
	    ## runs the deployment (changes state to run)
	    libkadeploy2::deploy_iolib::run_deployment($base,$deployment);	                                 
	    libkadeploy2::deploy_iolib::end_deployment($base,$deployment);
	    ###until here	    
	    libkadeploy2::deploy_iolib::disconnect($base);
	}
      }
  }

if ($noreboot) {
  print ("[VERBOSE] noreboot option chosen\n") if ($verbose);
  exit (1);
}

my @hosts_to_reboot_hard;

my $index = 0;
my $timeout = 5;
my $window_size = 50;

# Now, we have to reboot the nodes efficiently
if (!$hard) { # there should be a timed operation
  my %running_processes;
  my %finished_processes;
  my $host;

  while (scalar(keys(%finished_processes)) <= $#hosts_to_reboot){
    while((scalar(keys(%running_processes)) < $window_size) && ($index <= $#hosts_to_reboot)){
      print("[VERBOSE] fork process for the node $hosts_to_reboot[$index]\n") if ($verbose);
      my $pid = fork();
      if (defined($pid)){
	if ($pid == 0){
	  #In the child
	  # Initiate timeout
	  alarm($timeout);
	  $host = $hosts_to_reboot[$index];
	  my $cmd = $cmd{$host}{$reboot};
	  print("[VERBOSE] Execute command : $cmd\n") if ($verbose);
	  exec($cmd);
	}
	$running_processes{$pid} = $index;
      }else{
	warn("/!\\ fork system call failed for node $hosts_to_reboot[$index].\n");
      }
      $index++;
    }
    my $pid = wait();
    my $exit_value = $? >> 8;
    my $signal_num  = $? & 127;
    my $dumped_core = $? & 128;
    
    if ($pid == -1){
      die("/!\\ wait return -1 so there is no child process. It is a mistake\n");
    }else{
      if (defined($running_processes{$pid})){
	print("[VERBOSE] Child process $pid ended : exit_value = $exit_value, signal_num = $signal_num, dumped_core = $dumped_core \n") if ($verbose);
	$finished_processes{$running_processes{$pid}} = [$exit_value,$signal_num,$dumped_core];
	delete($running_processes{$pid});
      }
    }
  }
  
  foreach my $i (keys(%finished_processes)){
    my $verdict = "BAD";
    if (($finished_processes{$i}->[0] == 0) && ($finished_processes{$i}->[1] == 0) && ($finished_processes{$i}->[2] == 0)){
      $verdict = "GOOD";
    }
    print("$hosts_to_reboot[$i] : $verdict ($finished_processes{$i}->[0],$finished_processes{$i}->[1],$finished_processes{$i}->[2])\n");
    push (@hosts_to_reboot_hard, $hosts_to_reboot[$i]);
  }
} else {
  @hosts_to_reboot_hard = @hosts_to_reboot;
}

foreach my $host (@hosts_to_reboot_hard){
  if ($cmd{$host}{"hardboot"}) {
    print ("[VERBOSE] rebooting node $host hard \n") if ($verbose);
    system ($cmd{$host}{"hardboot"}." &");
  } else {
    print "No hardboot command found for node $host \n";
  }
}
