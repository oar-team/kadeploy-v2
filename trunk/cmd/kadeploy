#!/usr/bin/perl

use File::Copy;
use Getopt::Long;
use libkadeploy2::deploy_iolib;
use libkadeploy2::rights_iolib;
use libkadeploy2::conflib;
use libkadeploy2::bootlib;
use libkadeploy2::node_bd;
use libkadeploy2::nodes;
use warnings;
use strict;



## flush stdout
$| = 1;

## declares the function
sub check_options();
sub check_consistency();
sub check_nodes($$);
sub check_partition($$$);
sub check_env($$$);
sub set_tar_options($);
sub set_mkfs_option($);
sub halt($);

## declares the options
my $env = '';               # env name to be deployed
my @host_list = ();         # host list to deploy on
my $device = '';            # device & partition number
my $node_file = '';         # file describing nodes to be deployed

## declares other global variables
my $base;                   # database reference
my $deployment;             # deployment identifier
my $environment;            # environment identifier

my $username;               # real user

my $envid=0;		    # environment id
my @db_checked_hosts = ();  # nodes existing in database
my $dev;                    # device e.g. hda
my $part;                   # partition number e.g. 1
my $destination_partition;  # deployment target partition e.g. /dev/hda1
my $destination_disk;       # deployment target disk e.g /dev/hda
my $grub_boot_img_name;     # grub boot image name e.g. grub_deploy_debian_bootvmlinuz_hda1
my $grub_menu_file_name;    # grub menu file name e.g. menu1_hda1
my $pre_install_archive;    # path to pre-install archive
my $pre_install_option;     # tar options for pre-install archive
my $pre_install_script;     # name of the pre-install script
my $mkfs_fs;                # parameter for mkfs command
my $filesystem;             # filesystem type
my $filebase;               # path to environment image
my $filebase_option;        # tar options for environment image
my $filesite;               # path to site specification site
my $filesite_option;        # tar options for specification site
my $post_script;            # name of the post-install script
my $tftp_destination_folder;# tftp destination folder
my $kernel_path;            # path to kernel in env image
my $kernel_param;           # boot kernel parameter
my @to_check = ();          # deployed nodes to check
my @ready = ();             # deployed nodes that are ready 
my $time_preinstall;        # used for time bench
my $time_transfert;
my $usetar=0;
my $pre_pipe;			
my $dest_pipe;
my $post_pipe;

## Configuration
my $configuration = libkadeploy2::conflib->new();
## Nodes sets used during deployment process
my $nodes_set;
my $deployed_nodes_set;
## Deployment method
my $deployment_nodes=0; # 
my $depmethod;    #command variable for deployment method 
		  #	0    	default (normal kadeploy 2reboots)
		  #     1	kadeploy with no 1st reboot 
		  #     2	kadeploy with no 1st, no 2nd reboot

my $bootstrap=0;  # deploy an environment from the linuxdeploy env (rsh) : no first reboot
my $user;
my $nodetype;
my $verbose;
my $rambinpath="/mnt/rambin/";
my $remote_fdisk_file="$rambinpath/fdisk_user.txt";
my $remote_preinstall_conf="$rambinpath/preinstalldisk.conf";

if ($ENV{SUDO_USER})
{  $username=$ENV{SUDO_USER}; }
else
{ $username=$ENV{USER}; }

## to prevent zombie processes
## SIGCHLD is ignored and when the child dies, his father does not care...
#$SIG{CHLD} = 'IGNORE';
## enables kadeploy to catch the Ctrl-C signal
## in order to correct the database before exiting
$SIG{INT} = \&tsktsk;

## checks the options and load configuration file
if(!check_options()) {     exit 0; }


## continue with variables requiring configuration file
my $do_fdisk_on_deploy="no"; # default behaviour
if ($configuration->get_conf("do_fdisk_on_deploy")) {$do_fdisk_on_deploy = $configuration->get_conf("do_fdisk_on_deploy");}
my $kadeploydir=$configuration->get_conf("kadeploy2_directory");
my $deployuser=$configuration->get_conf("deploy_user");
my $help;
my $defaultpartitionfile="/etc/kadeploy/clusterpartition.conf"; #a partition file default /etc/kadeploy/clusterpartition.conf
my $partitionfile;       #a partition file default /etc/kadeploy/clusterpartition.conf

my $defaulttargetpartition="";
if ($configuration->get_conf("default_target_partition")) {
        $defaulttargetpartition = $configuration->get_conf("default_target_partition");
}

exit 0;

## Available variables are :
## - $env
## - @host_list ; (array of) nodes to be deployed
## - $dev e.g. hda
## - $part e.g. 1

## database connection
$base = libkadeploy2::deploy_iolib::connect();

if (!check_consistency())
{
    exit 0;
}

## checks if the user has appropriate rights
print "Checking user deployment rights...\n";
if(!( libkadeploy2::rights_iolib::check_rights_kadeploy($base,$username,\@db_checked_hosts,$device)))
{
    halt("user does not have appropriate rights on some nodes/partitions");
}

## new deployment creation
$deployment =  libkadeploy2::deploy_iolib::prepare_deployment($base);
if (!$deployment) { libkadeploy2::deploy_iolib::disconnect($base); exit 0; }


if($depmethod != 0)
{#optimisation method
     my $optsupport_nodes=0;
     foreach my $host (@db_checked_hosts)
     {
	 my $refpart = libkadeploy2::deploy_iolib::node_last_dep($base,$host);
	 my $depl = libkadeploy2::deploy_iolib::node_last_dep_env_optsupport($base,$host);
	 print "refpart=$refpart ,partition=$part, destination=$destination_partition \n";
	 if($refpart==$part)
	 {#if($refpart==$part)
	      $deployment_nodes++;
	      print "WARNING : node $host in deployment partition hda$refpart\n";
	  }
	 if($depl==0)
	 {
	     $optsupport_nodes++;
	     print "WARNING : the environment of node $host doesn't support\n";
	     print "optimisation method";
	 }
     }
     
     if ($deployment_nodes != 0||$optsupport_nodes!=0)
     {
	 if($deployment_nodes != 0)
	 {
	     print "WARNING:There are $deployment_nodes nodes that are in partition hda$part,\n";
	 }
	 if($optsupport_nodes!=0)
	 {
	     print "WARNING:There are $optsupport_nodes nodes that don't support optimisation method\n";
	 }
	 
	 print "cannot proceed with fast deployment method,\n";
	 print "proceeding with normal deployment method\n";

#no optimisation method


	 $nodetype="deployment";
	 $depmethod=0;
     }
     else
     {
	 print "All nodes in different partition than $part, \n";
	 print "All environments support optimisation method";
	 print "proceeding with fast deployement method \n";
	 $nodetype="production";
     }		 
}
else
{
    #no optimisation method
    $nodetype="deployment";
}


## effectue un reboot deploiement soft
if ($depmethod==0)
{	
#    if ($bootstrap==0) 
#    { 
#	libkadeploy2::bootlib::reboot(\@host_list,"1","0","1");
#      }
    $pre_pipe="/pre_pipe";
    $dest_pipe="/dest_pipe";
    $post_pipe="/post_pipe";        
    $pre_install_script="$pre_install_script fdisk";
}
else{
	$pre_pipe="/tmp/pre_pipe";
    	$dest_pipe="/tmp/dest_pipe";
        $post_pipe="/tmp/post_pipe";
}
	
###############################################
## (au cas ou si besoin est)                 ##
## effectue un reboot deploiement hard       ##
## bootlib::reboot(\@host_list,"0","1","1"); ##
###############################################


$nodes_set = libkadeploy2::nodes->new($nodetype,$verbose);


## deployment node set creation
my %ip_addr;
foreach my $host (@db_checked_hosts) { $ip_addr{$host} = [$dev,$part]; }

## begins deployment (updates deployed table)
$environment = libkadeploy2::deploy_iolib::env_name_user_to_last_ver_id($base,$env,$user);

my @nodes_ready = ();
foreach my $key (keys %ip_addr)
{
    my $value = $ip_addr{$key};
    push(@nodes_ready,$value);
}


if(!scalar(@nodes_ready))
{
    halt("deployment canceled");
}

## creates nodes set for deployment
# Nodes->new("production") for testing purposes
# Nodes->new("deployment") for real deployment
#
#$nodes_set = libkadeploy2::Nodes->new("deployment"); 



my $tmp_node;
# for the moment, nodes' name and IP are the same
#


print "registering environment: " . $envid . "for this deployment:" . $deployment . "\n";
foreach my $host (@db_checked_hosts){
    $tmp_node = libkadeploy2::node_bd->new($host, $deployment, $envid, $dev, $part);
    if ($tmp_node) 
    {
	$nodes_set->add($tmp_node);
    }
    else 
    {
	print "node $host not included in current deployment\n";
    }
}


## runs the deployment (changes state to run)
libkadeploy2::deploy_iolib::run_deployment($base,$deployment);

# Let start the chronometer
my $checkTimeout = $configuration->get_conf("first_check_timeout");

# rebooting the nodes
if ($bootstrap == 0) {
    $nodes_set->rebootMyNodes("deployboot");
    if ($nodes_set->rebootMyNodes("softboot") == 0) {
        # if node is rebooted from deploy environment the check is too fast => preinstall begins before effective reboot!
        sleep (20);
    }
} 


## waits for all the nodes to be ready
# first check is important before ready to ensure
# node state coherancy
if ($checkTimeout <= 0) { # invalid value
	$checkTimeout = 200;
}
print "Waiting for all the nodes to reboot during $checkTimeout seconds\n";

my $reference_time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment);
my $time_check = 0;


print "<BootInit 0>\n";
$nodes_set->initCheck();

while((!$nodes_set->ready()) and ($time_check < $checkTimeout)) 
{
    $nodes_set->initCheck();
    $time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment) - $reference_time_check;
    sleep(1);
}

if ($nodes_set->ready()) {
    print "All nodes are ready!\n";
} else {
    if($depmethod==0) {
        if ($bootstrap==0) {
	    print "There are some missing nodes, rebooting them hard!\n";
	    $nodes_set->rebootMyNodes("failednodes");
	}
        # let's wait for another timeout
        $reference_time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment);
        $time_check = 0;
        $nodes_set->check();
        while((!$nodes_set->ready()) and ($time_check < $checkTimeout))
        {
            $nodes_set->check();
            $time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment) - $reference_time_check;
            sleep(1);
        }
        if ($nodes_set->ready())
        {
            print "All nodes are ready!\n";
        }
        else
        {
            print "There are some missing nodes, pursuing deploy process!\n";
        }
    }
}


# time bench
my $time_first_check = libkadeploy2::deploy_iolib::get_time($base,$deployment);
libkadeploy2::deploy_iolib::set_time($base,$deployment);
print "First Check: " . $time_first_check . "\n";

#
# Let's go!
#
$destination_disk = "/dev/".$dev;
$destination_partition = "/dev/" . $dev . $part;

#
#preparation for deployment optimisation method 
#
if($depmethod!=0)
{
    $nodes_set->runRemoteCommand("\" umount /mnt/rambin \"");
    $nodes_set->runRemoteCommand("\" umount /mnt/dest \"");
    $nodes_set->runRemoteCommand("\" mkdir /mnt/rambin \"");
    $nodes_set->runRemoteCommand("\" mkdir /mnt/dest \"");
    $nodes_set->runRemoteCommand("\" mkdir /mnt/tmp \"");
    $nodes_set->runRemoteCommand("\" ln -s /mnt/rambin /rambin \"");
    $nodes_set->runRemoteCommand("\" mount -t tmpfs tmpfs /mnt/rambin \"");
    $nodes_set->runRemoteCommand("\" mkfifo /tmp/pre_pipe \"");
    $nodes_set->runRemoteCommand("\" mkfifo /tmp/dest_pipe \"");
    $nodes_set->runRemoteCommand("\" mkfifo /tmp/post_pipe \"");
    $nodes_set->runRemoteCommand("\" chmod a+w /tmp/pre_pipe /tmp/dest_pipe /tmp/post_pipe \"");
    $nodes_set->runCommandSimplessh("(tar zxC < /tmp/pre_pipe /rambin)");
    $nodes_set->runCommandSimplessh("(tar zxC < /tmp/dest_pipe /mnt/dest)");
    $nodes_set->runCommandSimplessh("(tar zxC < /tmp/post_pipe /rambin)");		      
}

#umount the destination partition ( if a kadeploy has canceled before )
$nodes_set->runRemoteCommand("\" umount /mnt/dest \"");

print "<PreInstall>\n";
# pre-installation
# mount rambin to perform hd optimizations and benches,...
print "Retrieving preinstall\n";

$nodes_set->runCommandMcat("cat $pre_install_archive", $pre_pipe);

if ($depmethod==0 && $do_fdisk_on_deploy eq "yes")
{
    # TODO: à remplacer par une autre commande
    $nodes_set->runCommandMcat("$kadeploydir/sbin/kasetup -loadpartitionfile $partitionfile -printvalidfdisk", "cat > $remote_fdisk_file");
}

print "Executing preinstall...";

#$nodes_set->runRemoteCommand("\" /usr/local/bin/wait_background.sh /var/lock/preinstall \"");
$nodes_set->runRemoteCommandBackgroundReportFailed("$rambinpath/$pre_install_script", "preinstall", "Preinstall failed on node");
print "Done\n";

# time bench
$time_preinstall = libkadeploy2::deploy_iolib::get_time($base,$deployment);
print "Preinstall: " . $time_preinstall . "\n";




print "<Transfert>\n";
libkadeploy2::deploy_iolib::set_time($base,$deployment);



print "filebase: $filebase\n";
if ($filebase =~ /^.+\.tar\.gz$/ ||
    $filebase =~ /^.+\.tgz$/     )
{
    $usetar=1;
# format desired partition and mount it
    print "Formatting destination partition $destination_partition on the nodes...";
#    $nodes_set->runRemoteCommand("\" mkfs -t $mkfs_fs $destination_partition \"");
    my $mkfs_fs_options = " ";
    if($configuration->get_conf($mkfs_fs . "_options")) {
	    $mkfs_fs_options = $configuration->get_conf($mkfs_fs . "_options");
    }
    print "using $mkfs_fs file system with options: $mkfs_fs_options \n";
    $nodes_set->runRemoteCommandBackground("mkfs -t $mkfs_fs $mkfs_fs_options $destination_partition", "format");
    $nodes_set->runRemoteCommandReportFailed("\" mount $destination_partition /mnt/dest \"", "mount of $destination_partition failed on node"); # if mount does not work transfert cannot be done
    print "Done\n";

    
    print "<tar Transfert>\n";
# send the environment!!
    print "Sending Computing environment to the nodes...\n";
    $nodes_set->runCommandMcat("cat $filebase", $dest_pipe);
    print "Done\n";
}
if ($filebase =~ /^.+\.dd\.gz$/)
{
    print "<dd Transfert>\n";
    print "Sending Computing environment to the nodes...\n";
    $nodes_set->runRemoteCommand("\" ln -sf $destination_partition /dest_part \"");
    $nodes_set->runCommandMcat("cat $filebase", "/destdd_pipe");
    #$nodes_set->runCommandMcat("cat $filebase", "gzip -dc | cat > $destination_partition", $mcat_first_port); 
    print "Done\n";
}

$time_transfert = libkadeploy2::deploy_iolib::get_time($base,$deployment);
print "Transfert: " . $time_transfert . "\n";


if ($usetar)
{
    print "<PostInstall>\n";
    libkadeploy2::deploy_iolib::set_time($base,$deployment);
# post-installation
    print "Executing postinstall...";
    $nodes_set->runCommandMcat("cat $filesite", $post_pipe);
    $nodes_set->runRemoteCommandBackground("\" /rambin/$post_script /rambin \"", "postinstall");
    print "Done\n";

# time bench

    my $time_postinstall = libkadeploy2::deploy_iolib::get_time($base,$deployment);
    print "Postinstall: " . $time_postinstall . "\n";
    
    my @to_reboot = @db_checked_hosts;
}

my @to_reboot = @db_checked_hosts;

#2nd optimisation method pivot root
#problems to be resolved: mysql ...
if($depmethod==2)
{
    print "Proceeding with pivot-deployment method...";
    $nodes_set->runRemoteCommand("\" mkdir /mnt/dest/old_root \"");
    $nodes_set->runRemoteCommand("\" rm -f /mnt/dest/etc/mtab \"");
    $nodes_set->runRemoteCommand("\" mkdir /new_root \"");
    $nodes_set->runCommandSimplessh("/rambin/rc1stop");
    sleep(10);
    $nodes_set->runRemoteCommand("\" mount $destination_partition /new_root \"");
    $nodes_set->runCommandSimplessh("/rambin/pivot");
    sleep(13);	
    print "Pivot-deployment method finished.";
}
else{
if ($usetar)
{
    print "Umounting fs... ";
    $nodes_set->runRemoteCommand("\" umount $destination_partition  \"");
    sleep(1);
    print "Done\n";
}


# grub and pxe
libkadeploy2::bootlib::setup_grub_pxe($base,$deployment);

if($depmethod==0)
{
    $nodes_set->rebootThoseNodes();}
else
{
    $nodes_set->runRemoteSystemCommand("\"reboot -f >/dev/null 2>&1 &\"");
}
print "rebooting the nodes...\n";
}

# time transfert
#$time_transfert = libkadeploy2::deploy_iolib::get_time($base,$deployment);
libkadeploy2::deploy_iolib::set_time($base,$deployment);
#print "Transfert: " . $time_transfert . "\n";

@to_reboot = $nodes_set->getReadyNodes();
# discard the previous nodes' set to allow the creation of a new one
$nodes_set->discard();
# Waits for all the nodes to be there
$deployed_nodes_set = libkadeploy2::nodes->new("production"); 

foreach my $hostName (@to_reboot)
{
    $tmp_node = $nodes_set->get_node_by_name($hostName);
    $tmp_node->get_name();
    $deployed_nodes_set->add($tmp_node);
}


# check if all the nodes rebooted
#
# the first check is important, because the added nodes were there,
# during the deployment procedure.
# It ensures that their state is synchronized with the new conditions
# that grants that a node is there

# let's wait for another timeout
$reference_time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment);
$time_check = 0;


$checkTimeout = $configuration->get_conf("last_check_timeout");
if ($checkTimeout <= 0) { # invalid value
        $checkTimeout = 300;
}
print "Waiting for all the nodes to reboot during $checkTimeout seconds\n";

$deployed_nodes_set->lastCheck();
while((!$deployed_nodes_set->ready()) and ($time_check < $checkTimeout)) 
{
    $deployed_nodes_set->lastCheck();
    $time_check = libkadeploy2::deploy_iolib::get_time($base,$deployment) - $reference_time_check;
    sleep(1);
}

#$deployed_nodes_set->check();
#while(!$deployed_nodes_set->ready()) {
#    $deployed_nodes_set->check();
#}
#print "All nodes are deployed!\n";
print "Deployment finished!\n";

print "<Completed>\n";

# time end
my $time_end = libkadeploy2::deploy_iolib::get_time($base,$deployment);
libkadeploy2::deploy_iolib::set_time($base,$deployment);
print "Last Reboot: " . $time_end . "\n";

## error if a node failed then checks which node has failed
## and turns the others to 'deployed' state
my $exit_value = libkadeploy2::deploy_iolib::end_deployment($base,$deployment);
libkadeploy2::deploy_iolib::debug_print($base,$deployment);
libkadeploy2::deploy_iolib::disconnect($base);

print "\n\nSumary:\n\tfirst reboot and check: " . $time_first_check . "\n\tpreinstall:" . $time_preinstall . "\n\ttransfert: " . $time_transfert . "\n\tlast reboot and check: " . $time_end . "\n";

# exits with a shell compatible status
exit (1-$exit_value);

1;
###################### End of Main ########################














################## Function Definition ####################

# check_nodes
# checks if the specified nodes exist in the database
# parameters : base, host list (name or ip adress)
# return value : list of hosts that exist in the database or 0 if empty
sub check_nodes($$){
    my $dbh = shift;
    my $ref_hosts = shift;
    my @checked;

    foreach my $host (@{$ref_hosts}){
	if(! libkadeploy2::deploy_iolib::node_name_to_name($dbh,$host)){
	    my $hostname =  libkadeploy2::deploy_iolib::node_ip_to_name($dbh,$host);
	    if(!$hostname){
		print "WARNING : node $host does not exist in the database\n";
		print "WARNING : it is excluded from deployment\n";
	    }else{
		push(@checked,$hostname);
	    }
	}else{
	    push(@checked,$host);
	}
    }
    return @checked;
}

# check_partition
# checks if the partition exists
# parameters : base, disk, partition
# return value : 0 if disk or partition does not exist
# NB : very simple version ; to be improved...
#      disk_dev_to_id & part_nb_to_id should make a join
#      with the deployed table...
sub check_partition($$$){
    my $dbh = shift;
    my $dev = shift;
    my $part = shift;

    return ( libkadeploy2::deploy_iolib::disk_dev_to_id($dbh,$dev));
    #return (deploy_iolib::disk_dev_to_id($dbh,$dev) && deploy_iolib::part_nb_to_id($dbh,$part));
}

# check_env
# checks if the environment exists
# parameters : base, environment
# return value : 0 if env does not exist
# NB : naive version, should check if needed fields are filled in or not
#      and if values are consistent ; except if done by KaCreateEnv
sub check_env($$$)
{
    my $dbh  = shift;
    my $env  = shift;
    my $user = shift;
    
    return  libkadeploy2::deploy_iolib::env_name_user_to_last_ver_id($dbh,$env,$user);
}

# set_tar_options
# set the tar options
# parameters : archive name
# return value : the tar options or 0 if unknown format
sub set_tar_options($){
    my $archive = shift;
    my $extension = $archive;
    
    if($extension=~ /\.tar\.bz2$/)
    {
	return "jxC";
    }
    elsif($extension =~ /\.tar\.gz$/)
    {
	return "zxC";
    }
    elsif($extension =~ /\.tgz$/)
    {
	return "zxC";

    }
    elsif($extension =~ /\.tar$/)
    {
	return "xC";
    }
    else
    {
	print "ERROR : unknown archive format $extension\n";
	return 0;
    }
}

# set_mkfs_option
# only replace ext3 by ext2 for the moment
# parameters : filesystem
# return value : filesystem
sub set_mkfs_option($){
    my $fs = shift;
    
    if($fs eq "ext3"){
	return $fs;
    }else{
	return $fs;
    }
}



sub usages()
{
    print "Use : kadeploy 
\t[-m   | --machine     hostname] 
\t[-f   | --file        node_file]                 Choose -m XOR -f
\t[-e   | --environment environment_name]
\t[-p   | --partition   partition]
\t[-h   | --help]                                  This help message
\t[-l                   username]                  Default : $username

";


#print "\t[-d 0 | 1] Optimisation support\n"

#    if ($do_fdisk_on_deploy eq "yes")
#    {
#	print "\t[-lpf | --loadpartitionfile partitionfile]\n";
#    }
}


# check_options
# make all sort of checks
# parameters :
# return value : 1 if successful
sub check_options(){

    if (!@ARGV){
	usages();
	exit 0;
    }
    
    ## gets the options
    GetOptions('e=s'                 => \$env,
	       'environment=s'       => \$env,
	       'm=s'                 => \@host_list,
	       'machine=s'           => \@host_list,
	       'f=s'                 => \$node_file,
	       'file=s'              => \$node_file,
	       'p=s'                 => \$device,
	       'partition=s'         => \$device,
	       'd=s'                 => \$depmethod,
	       'bootstrap'           => \$bootstrap,
	       'l=s'                 => \$user,
	       'loadpartitionfile=s' => \$partitionfile,
	       'lpf=s'               => \$partitionfile,
	       'v!'                  => \$verbose,
	       'verbose'             => \$verbose,
	       'h'                   => \$help,       
	       'help!'               => \$help,
	       );


    ## first read command options    
    if ($help) { usages(); exit(0); }

    ## separates device and partition number from $device
    $dev = substr($device, 0, 3);
    my @nb = split(/$dev/, $device);
    $part = $nb[1];


    if ((scalar(@host_list) && $node_file) || (!@host_list) && (!$node_file)) {
        print "ERROR : hosts have to be specified, using either the -m OR the -f option\n";
        exit 1;
    }
    
    if ($node_file){
        if(!(-s $node_file)){
            print "ERROR : specified node file does not exist or is empty\n";
            exit 1;
        }
        ## goes through the file and get the hostnames
        my $line;
        open(NODEFILE,$node_file);
        while ($line = <NODEFILE>)
        {
            if ($line =~ /([a-zA-Z0-9\.\-]+)/) { $line = $1; }
            chomp($line);
            push(@host_list, $line);
        }
    }
    
    # load configuration files
    if (!$configuration->check_nodes_conf(\@host_list) || !$configuration->check_conf()) {
	print "ERROR : problem occured loading configuration file\n";
	exit 1;
    }

    if (!$user) { $user=$username;  }

    ## checks if needed options are defined
    if (!$env){
	print "ERROR : environment name needed\n";
	exit 1;
    }
    if (!$device){
	if ($defaulttargetpartition eq "") {
	    print "ERROR : target partition unspecified\n";
	    exit 1;
        } else {
            $device = $defaulttargetpartition;
	    print "no target partition specified, using default one: $device\n";
	}
    }
    if(!$depmethod){
    	# print"No deployment method specified, proceeding with normal deployment\n";
	$depmethod=0;
    }   
    if($depmethod<0 || $depmethod>2){
        print"ERROR: deployment method should be one of the following:\n";
    	print"   0     default (normal deployment 2reboots)\n";
	print"   1     1st optimized deployment with no 1st reboot\n";
        print"   2     2nd optimized deployment with no 1st, no 2nd reboot\n";
	exit 1;
    }

    # register configuration for the different modules
    libkadeploy2::deploy_iolib::register_conf($configuration);
   


    # additional checks
    if ($do_fdisk_on_deploy)
    {
        if ($do_fdisk_on_deploy eq "no" &&
            $partitionfile)
        {
            print "ERROR : you are not allowed to repartition your harddrive.\n";
            exit 1;
        }

        if ($do_fdisk_on_deploy eq "yes")
        {
            if (!$partitionfile) { $partitionfile=$defaultpartitionfile; }
            if(! -e $partitionfile)
            {
                print "ERROR : partition file $partitionfile not found.\n";
                exit 1;
            }
        }
    }

    #FIX partitionfile to default
    if (!$partitionfile) { $partitionfile=$defaultpartitionfile; }

    return 1;
}

# check_consistency
# make all sort of checks
# parameters : 
# return value : 1 if successful
sub check_consistency()
{
    my $dopostinstall=1;
    ## check partitioning schema
    if ($do_fdisk_on_deploy && $do_fdisk_on_deploy eq "yes" && system("$kadeploydir/sbin/kasetup -loadpartitionfile=$partitionfile -printvalidfdisk >/dev/null")!=0)
    {
	halt("ERROR : partition check failed\n");
    }
    ## checks if specified nodes are registered
    @db_checked_hosts = check_nodes($base,\@host_list);
    if(!scalar(@db_checked_hosts)){ 
	halt("none of the specified nodes is registered");
    }

    ## checks if specified partition exists
    if(!check_partition($base,$dev,$part)){
	halt("target partition does not exist");
    }

     ## checks if specified environment exists
    $envid=check_env($base,$env,$user);
    if($envid==0)
    {
	print "specified env $env does not exist for user $user\n";
	print "searching for env $env with user $deployuser\n";
	$envid=check_env($base,$env,$deployuser);
	if($envid==0)
	{
	    halt("No environment $env found with user $deployuser\n");
	}
    }


    # gets filebase path
    $filebase =  libkadeploy2::deploy_iolib::env_id_to_filebase($base,$envid);
    # instead of the following line ? (cleaner) (not tried yet)
    # my @cut = split(/:/, $filebase);
    # $filebase = $cut[1];
    $filebase = substr($filebase,6);

    # checks if the file exists
    if(!(-e $filebase)){
	halt("base file does not exist");
    }elsif(!(-r $filebase)){
	halt("base file exists but is not allowed to be read by user $username");
    }
    # checks format file and prepare tar options
    if (
	($filebase =~ /\.tgz$/ || 
	 $filebase =~ /\.tar\.gz$/
	 )
	)
    {
	$filebase_option = set_tar_options($filebase);
	if (!$filebase_option)
	{
	    halt("unknown pre install archive format");
	}	
    }
    else
    {
	$dopostinstall=0;
    }
    
    # gets kernel path
    $kernel_path =  libkadeploy2::deploy_iolib::env_id_to_kernel($base,$envid);

    # checks if kernel path is specified
    if(!$kernel_path){
	halt("no kernel path specified in the database !");
    }
    
    # gets filesystem
    $filesystem =  libkadeploy2::deploy_iolib::env_id_to_filesystem($base,$envid);

    # checks if the filesystem is defined
    if(!$filesystem){
	halt("no file system specified in the database !");
    }
    
    # prepare mkfs options
    $mkfs_fs = set_mkfs_option($filesystem);

    # pre-install preparation and check

    # gets needed stuff from conf file
    $pre_install_archive =  $configuration->get_conf("pre_install_archive");

    # checks if it exists
    if(!(-e $pre_install_archive) ){
	halt("pre install archive does not exist");
    }elsif(!(-r $pre_install_archive) ){
	halt("pre install archive exists but is not allowed to be read by $username");
    }

    # checks format file and prepare tar options
    $pre_install_option = set_tar_options($pre_install_archive);
    if (!$pre_install_option){
	halt("unknown pre install archive format");
    }

    $pre_install_script =  $configuration->get_conf("pre_install_script");

    # checks if it exists
    if(!$pre_install_script){
	halt("pre install script is not specified !");
    }

    # post-install preparation and check

    # gets filesite path
    $filesite =  libkadeploy2::deploy_iolib::env_id_to_filesite($base,$envid);
    # instead of the following line ? (cleaner) (not tried yet)
    # @cut = split(/:/, $filesite);
    # $filesite = $cut[1];
    $filesite = substr($filesite,6);

    # checks if the file exists
    if ($dopostinstall)
    {
	if(!(-e $filesite))
	{
	    halt("site file does not exist");
	}
	elsif(!(-r $filesite))
	{
	    halt("site file exists but is not allowed to be read by $username");
	    
	}
	# checks format file and prepare tar options
	$filesite_option = set_tar_options($filesite);
	if (!$filesite_option)
	{
	    halt("unknown post install archive format");
	}
    }


    # gets needed stuff from conf file
    $post_script =  $configuration->get_conf("post_install_script");

    # checks if it exists
    if(!$post_script){
	halt("post install script is not specified !");
    }

    # kernel param 
    $kernel_param = '';
    $kernel_param =  $configuration->get_conf("kernel_param");
    
    return 1;
}

# halt
# cancel a deployment, disconnect from database and exit from program
# parameters : string to print
# return value : 1 if successful
sub halt($){
    my $msg = shift;

    print "ERROR : $msg\n";
    libkadeploy2::deploy_iolib::cancel_deployment($base,$deployment);
    libkadeploy2::deploy_iolib::disconnect($base);
    exit 0;
}

sub tsktsk {
    $SIG{INT} = \&tsktsk;           # See ``Writing A Signal Handler''
    print "Signal caught...\n";
    # checks if $base exists i.e. if kadepoy has already connected to the database
    if($base)
    {
	if($deployment)
	{
	    libkadeploy2::deploy_iolib::correct_deployment_consistence($base,$deployment);
	  }
    }
    print "Database corrected\nExiting...\n";
    # clean the remaining processes
    if ($deployed_nodes_set)
    {
	if ($deployed_nodes_set != 0) 
	{
	    print "killing sentinelle\n";
	} 
	elsif ($nodes_set != 0) 
	{
	    print "killing sentinelle\n";
	}
    }
    exit 0;
}
